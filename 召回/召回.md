# Item CF

判断物品相似度还可以用知识图谱

Item CF = 用户对历史交互物品A兴趣（比如点击是1分，点赞是2分）* 待计算物品和A的相似度 + 用户对历史交互物品B兴趣* 待计算物品和B的相似度 + ...

相似度 = 同时喜欢（没有区分喜欢的程度）两物品的人数 / 喜欢物品A的人数 * 喜欢物品B的人数 的 平方根

![[Pasted image 20250922232400.png]]

余弦相似度

先做离线计算 - 维护两个索引：==索引可以避免枚举所有物品==
+ 用户 - > 物品 给定用户ID 返回最近交互的物品 ==这个列表长度是否固定？==
+ 物品 - > 物品 给定物品ID 返回==最相似的k个物品==

线上召回 - 先找到last-n物品列表 即参与计算的用户 - > 物品列表长度是固定的n
再取回topk物品 一共有nk个物品

离线计算量大 线上召回计算量小

# Swing

Item CF的一种变体 如果两个物品拥有的共同用户越多 那么这两个用户越相似 Swing考虑一种情况 如果两个物品的共同用户来自同一个小群体 那么他们对相似度的贡献应该降低 即应该加入惩罚项

判定用户是否相似的计算方法：Overlap(u1,u2) = u1喜欢的物品和u2喜欢物品的交集

两个物品的Swing相似度 = 1 / factor + overlap(u1,u2) u1 u2来自喜欢两个物品的用户交集 
==并不是用户重合度越高物品相似度越低 重合度高只会降低贡献 并不提供负贡献==

# User CF 

离线算用户相似度

某用户对某物品的兴趣 = 用户A和该用户的相似度 * 用户A对候选物品的兴趣分数 + 用户B和该物品的相似度 * 用户B对候选物品的兴趣分数 ... 

用户相似度 = 两用户喜欢物品的交集大小 / 两用户喜欢物品数量的乘积的平方根 （无喜欢程度）

==降低热门物品权重== 大家都喜欢看哈利波特 那么哈利波特对用户相似度的贡献应该降低
具体公式如下
![[Pasted image 20250924212647.png]]

同样维护两个索引
+ 用户 - > 物品 ：和itemcf一模一样 返回最近交互的物品
+ 用户 - > 用户：索引和用户最相似的k个用户（计算量大）
利用两个索引线上做召回

# 离散特征处理

主要两种方式
+ 独热 - 纬度高 稀疏
+ Embedding - 纬度低 稠密 - 维护序号到向量的映射

# 矩阵补充（不常用）
![[Pasted image 20250924213629.png]]
内积的值越大 兴趣分数越高
两个嵌入层==不贡献==参数

用户嵌入参数矩阵的一列（一个向量）对应一个用户；物品嵌入参数矩阵同理
训练模型的目的 - 学习两个嵌入矩阵

求解优化问题： 找到一个参数矩阵A和B，使得所有真实评分和所有预测内积的差值最小

缺点：
+ 只用了ID 没用到任何物品或者用户属性（数据集就是三元组 uid iid rating）
+ 负样本的选取错误 - 曝光后有交互记录的是正样本 但是不能直接把曝光后没有点击交互的当成负样本
+ 内积当作分数不如使用余弦相似度；平方损失（回归） 不如用交叉熵（分类）

用户矩阵 直接存成kv表 用用户id来索引该用户对应的矩阵中的一列

## 最近邻查找 Nearest Neighbor Search
返回物品向量和用户向量的内积最大的k个物品 ==时间复杂度正比物品数量（枚举）==

近似最近邻查找
最近邻 - 欧式距离最近 向量内积最大 ==向量夹角最小（最常用）==

划分区域 - 用一个向量代表该区域 作为key 该区域所有点作为value - 定位到某一具体区域后再枚举

==usercf保存用户共同喜欢商品的时候如果直接用嵌套字典存复杂度有点大==

